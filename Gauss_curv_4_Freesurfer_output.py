# -*- coding: utf-8 -*-

"""
  Â©
  Author: Karim Makki
"""

### Reference: "Makki, K, Ben Salem, Douraied and Ben Amor, Boulbaba. "Towards the assessment of intrinsic geometry of implicit brain MRI manifolds." IEEE Access (2021)"

import trimesh
import numpy as np
import nibabel as nib
import os
from scipy.ndimage.filters import gaussian_filter
import argparse
import timeit
import fast_Gaussian_curvature_3D as g3D

## Import tools for computing curvature on explicit surfaces (for comparison purposes)
import slam_curvature as scurv
import CurvatureCubic as ccurv
import CurvatureWpF as WpFcurv
import CurvatureISF as ISFcurv
from trimesh import curvature
import DiffGeoOps as diffgeo


def load_mesh(gii_file):
    """
    load gifti_file and create a trimesh object
    :param gifti_file: str, path to the gifti file
    :return: the corresponding trimesh object
    """
    g = nib.gifti.read(gii_file)
    vertices, faces = g.getArraysFromIntent(nib.nifti1.intent_codes['NIFTI_INTENT_POINTSET'])[0].data, \
        g.getArraysFromIntent(nib.nifti1.intent_codes['NIFTI_INTENT_TRIANGLE'])[0].data
    metadata = g.get_meta().metadata
    metadata['filename'] = gii_file

    return trimesh.Trimesh(faces=faces, vertices=vertices,
                           metadata=metadata, process=False)


def map_coordinates(verts,aff):

    coords = np.zeros(verts.shape)
    coords[:,0] = aff[0,0]*verts[:,0] + aff[0,1]*verts[:,1] + aff[0,2]*verts[:,2] + aff[0,3]
    coords[:,1] = aff[1,0]*verts[:,0] + aff[1,1]*verts[:,1] + aff[1,2]*verts[:,2] + aff[1,3]
    coords[:,2] = aff[2,0]*verts[:,0] + aff[2,1]*verts[:,1] + aff[2,2]*verts[:,2] + aff[2,3]

    return coords


if __name__ == '__main__':

    parser = argparse.ArgumentParser()
    parser.add_argument('-in', '--mask', help='3D shape binary mask, as NIFTI file', type=str, required = True)
    parser.add_argument('-m', '--mesh', help='surface mesh generated by FreeSurfer, which corresponds to the mask nifti file, \
    as GIFTI file', type=str, required = True)
    parser.add_argument('-o', '--output', help='output directory', type=str, default = './Gaussian_curvature_results3D')
    parser.add_argument('-dmap', '--dmap', help='distance_map: 0 if Euclidean, 1 if geodesic distance map, and 2 if binary step function', type=int, default = 1)

    args = parser.parse_args()

    # Example of use : python3 Gauss_curv_4_Freesurfer_output.py -in /home/karim/Bureau/Courbure/data/Guillaume_data/rh_white.nii.gz
    #-m /home/karim/Bureau/Courbure/data/Guillaume_data/rh.white.gii

    output_path = args.output

    if not os.path.exists(output_path):
        os.makedirs(output_path)

    nii = nib.load(args.mask)

    shape = nii.get_data()

    affine = nii.affine


    start_time = timeit.default_timer()

    shape, dx, dy, dz = g3D.bbox_3D(shape)


    if (args.dmap == 1):

        phi = g3D.phi(shape) ## signed geodesic distance

    elif (args.dmap == 2):

        phi = g3D.phi_binary(shape) ## binary step function

    else:

        phi = g3D.phi_Euclidean(shape) ## signed Euclidean distance


    gaussian_filter(phi, sigma=2, output=phi) ## smoothing of the level set signed distance function

#################### Computation of  Gaussian curvature ###################
    phi_grad, hessian = g3D.hessian(phi)
    Ha = g3D.hessian_adjoint(hessian)
    Gaussian_curvature = g3D.Gaussian_curvature(phi_grad, Ha)
############################################################################

    elapsed = timeit.default_timer() - start_time
    print("The proposed method takes (in seconds):\n")
    print(elapsed)

    # Loading input mesh

    mesh = load_mesh(args.mesh)
    ## Express vertex coordinates in the image coordinate system
    verts = map_coordinates(mesh.vertices,np.linalg.inv(affine))

    #faces = mesh.faces
    #normals = mesh.vertex_normals

    verts = g3D.align_origin(verts,dx,dy,dz) ### Align origin with the origin of the bounding box

    ### Affect per-vertex curvature values, by interpolation

    #gaussian_curv = g3D.texture_nearest_neigh_interpolation3D(verts, Gaussian_curvature)
    #gaussian_curv = g3D.texture_mean_avg_interpolation3D(verts, Gaussian_curvature)
    gaussian_curv = g3D.texture_spline_interpolation3D(verts, Gaussian_curvature)

    verts = g3D.align_origin_back(verts,dx,dy,dz) ### Re-align origin "back" with the origin of the original image

    #### Save results as numpy array

    res = np.append(verts,gaussian_curv[...,None],axis=1)
    np.save(os.path.join(output_path, "gaussian_curv.npy"), res)
    print(res.shape)

    ## Display result
    #m = trimesh.Trimesh(vertices=mesh.vertices, faces=mesh.faces)
    mesh.export(os.path.join(output_path, "surface_mesh.ply"))

    g3D.display_mesh(mesh.vertices, mesh.faces, mesh.vertex_normals, gaussian_curv, os.path.join(output_path, "Gaussian_curature_Makki.png"))


##To compare results with other methods defining the surface explicitly, please comment/uncomment the following blocks ###############

# #######################################################################################################################################
# ############### To compare results with the Trimesh Gaussian curvature, please uncomment this block ##################################
#
#     start_time = timeit.default_timer()
#
#     #tr_gaussian_curv = curvature.discrete_gaussian_curvature_measure(m, m.vertices, 2)
#     tr_gaussian_curv = curvature.discrete_gaussian_curvature_measure(mesh, mesh.vertices, 2)
#
#     elapsed = timeit.default_timer() - start_time
#
#     print("The Trimesh method takes (in seconds):\n")
#
#     print(elapsed)
#
#     g3D.display_mesh(mesh.vertices, mesh.faces, mesh.vertex_normals, tr_gaussian_curv, os.path.join(output_path, "Gaussian_curvature_Trimesh.png"))
#
# ########################################################################################################################################
#
# #######################################################################################################################################
# ##### To compare results with the Rusinkiewicz (v1) Gaussian curvature, please uncomment this block ###################################
#
#     start_time = timeit.default_timer()
#     # Comptue estimations of principal curvatures
#     PrincipalCurvatures, PrincipalDir1, PrincipalDir2 = scurv.curvatures_and_derivatives(mesh)
#     gaussian_curv = PrincipalCurvatures[0, :] * PrincipalCurvatures[1, :]
#
#     elapsed = timeit.default_timer() - start_time
#
#     print("The Rusinkiewicz method v1 takes (in seconds):\n")
#     print(elapsed)
#
#     #gaussian_filter(gaussian_curv, sigma=1, output=gaussian_curv)
#     g3D.display_mesh(mesh.vertices, mesh.faces, mesh.vertex_normals, gaussian_curv, os.path.join(output_path, "Gaussian_curvature_Rusinkiewicz_v1.png"))
# #########################################################################################################################################
#
#
# #########################################################################################################################################
# ##### To compare results with the Rusinkiewicz (v2) Gaussian curvature, please uncomment this block #####################################
# ########################### Note that the second version is quite  faster than the first ################################################
#
#     start_time = timeit.default_timer()
#
#     #K,H,VN = WpFcurv.GetCurvatures(m.vertices,m.faces)
#     gaussian_curv = WpFcurv.GetCurvatures(mesh.vertices, mesh.faces)[0]
#
#     elapsed = timeit.default_timer() - start_time
#
#
#     print("The Rusinkiewicz method v2 takes (in seconds):\n")
#     print(elapsed)
#     #print(np.min(gaussian_curv),np.max(gaussian_curv), np.sqrt(np.absolute(np.mean(gaussian_curv)-(1/R**2))))
#
#     #gaussian_filter(gaussian_curv, sigma=1, output=gaussian_curv)
#     g3D.display_mesh(mesh.vertices, mesh.faces, mesh.vertex_normals, gaussian_curv, os.path.join(output_path, "Gaussian_curvature_Rusinkiewicz_v2.png"))
# #########################################################################################################################################
#
#
# #########################################################################################################################################
# ##### To compare results with those of the cubic order algorithm, please uncomment this block ###########################################
#
#     start_time = timeit.default_timer()
#
#     #K,H,VN = ccurv.CurvatureCubic(m.vertices,m.faces)
#     gaussian_curv = ccurv.CurvatureCubic(mesh.vertices,mesh.faces)[0]
#
#     elapsed = timeit.default_timer() - start_time
#
#     print("The cubic order algorithm takes (in seconds):\n")
#     print(elapsed)
#
#     #gaussian_filter(gaussian_curv, sigma=1, output=gaussian_curv)
#     g3D.display_mesh(mesh.vertices, mesh.faces, mesh.vertex_normals, gaussian_curv, os.path.join(output_path, "Gaussian_curvature_cubic_order.png"))
# ##########################################################################################################################################
#
# ########################################################################################################################################
# ##### To compare results with the iterative fitting method, please uncomment this block #################################################
#
#     start_time = timeit.default_timer()
#
#     gaussian_curv = ISFcurv.CurvatureISF2(mesh.vertices,mesh.faces)[0]
#
#     elapsed = timeit.default_timer() - start_time
#
#     print("The iterative fitting method takes (in seconds):\n")
#     print(elapsed)
#
#     #gaussian_filter(gaussian_curv, sigma=1, output=gaussian_curv)
#     g3D.display_mesh(mesh.vertices, mesh.faces, mesh.vertex_normals, gaussian_curv, os.path.join(output_path, "Gaussian_curvature_iterative_fitting.png"))
# ##########################################################################################################################################
# #
# #########################################################################################################################################
# ############## To compare results with the method of Meyer, please uncomment this block #################################################
#
#
#     start_time = timeit.default_timer()
#
#     A_mixed, mean_curvature_normal_operator_vector = diffgeo.calc_A_mixed(mesh.vertices, mesh.faces)
#     gaussian_curv = diffgeo.get_gaussian_curvature(mesh.vertices, mesh.faces, A_mixed)
#
#     elapsed = timeit.default_timer() - start_time
#
#     print("The method of Meyer takes (in seconds):\n")
#     print(elapsed)
#
#     g3D.display_mesh(mesh.vertices, mesh.faces, mesh.vertex_normals, gaussian_curv, os.path.join(output_path, "Gaussian_curvature_Meyer.png"))
# ##########################################################################################################################################

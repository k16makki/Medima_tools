# -*- coding: utf-8 -*-

"""
  Â©
  Author: Karim Makki
"""

#import visvis as vv
import trimesh
import numpy as np
import nibabel as nib
import os
from scipy import ndimage
from scipy.ndimage.filters import gaussian_filter
import argparse
from skimage import measure
import timeit
import fast_Gaussian_curvature_3D as g3D

## Import tools for computing curvature on explicit surfaces (for comparison purposes)
import slam_curvature as scurv
import CurvatureCubic as ccurv
import CurvatureWpF as WpFcurv
import CurvatureISF as ISFcurv
from trimesh import curvature
import DiffGeoOps as diffgeo



def hessian_trace(hessian):

    return hessian[0,0,...] + hessian[1,1,...] + hessian[2,2,...]


def mean_curvature(phi_grad,hessian):

    gx, gy, gz = phi_grad

    mean_curv =  (gx * (gx*hessian[0,0,...]+gy*hessian[1,0,...]+gz*hessian[2,0,...]) + gy * (gx*hessian[0,1,...]+gy*hessian[1,1,...]+gz*hessian[2,1,...])\
    + gz * (gx*hessian[0,2,...]+gy*hessian[1,2,...]+gz*hessian[2,2,...])) - (g3D.L2_norm_grad(gx,gy,gz)**2 *  hessian_trace(hessian))

    np.divide(mean_curv,-2*g3D.L2_norm_grad(gx,gy,gz)**3,mean_curv)
    #gaussian_filter(mean_curv, sigma=1, output=mean_curv)

    return mean_curv



def divergence_formula(phi):

    g_x,g_y,g_z = np.gradient(phi)
    #smoothing of gradient vector field
    gaussian_filter(g_x, sigma=2, output=g_x)
    gaussian_filter(g_y, sigma=2, output=g_y)
    gaussian_filter(g_z, sigma=2, output=g_z)
    norm_grad =  np.sqrt(np.power(g_x,2)+np.power(g_y,2)+np.power(g_z,2))
    norm_grad[np.where(norm_grad==0)]=1
    np.divide(g_x,norm_grad,g_x)
    np.divide(g_y,norm_grad,g_y)
    np.divide(g_z,norm_grad,g_z)
    g_xx, g_yx , g_zx = np.gradient(g_x)
    g_xy, g_yy , g_zy = np.gradient(g_y)
    g_xz, g_yz , g_zz = np.gradient(g_z)
    gaussian_filter(g_xx, sigma=2, output=g_xx)
    gaussian_filter(g_yy, sigma=2, output=g_yy)
    gaussian_filter(g_zz, sigma=2, output=g_zz)

    return  0.5*(g_xx + g_yy + g_zz)

def load_mesh(gii_file):
    """
    load gifti_file and create a trimesh object
    :param gifti_file: str, path to the gifti file
    :return: the corresponding trimesh object
    """
    g = nib.gifti.read(gii_file)
    vertices, faces = g.getArraysFromIntent(
        nib.nifti1.intent_codes['NIFTI_INTENT_POINTSET'])[0].data, \
        g.getArraysFromIntent(
            nib.nifti1.intent_codes['NIFTI_INTENT_TRIANGLE'])[0].data
    metadata = g.get_meta().metadata
    metadata['filename'] = gii_file

    return trimesh.Trimesh(faces=faces, vertices=vertices,
                           metadata=metadata, process=False)


def map_coordinates(verts,aff):

    coords = np.zeros(verts.shape)
    coords[:,0] = aff[0,0]*verts[:,0] + aff[0,1]*verts[:,1] + aff[0,2]*verts[:,2] + aff[0,3]
    coords[:,1] = aff[1,0]*verts[:,0] + aff[1,1]*verts[:,1] + aff[1,2]*verts[:,2] + aff[1,3]
    coords[:,2] = aff[2,0]*verts[:,0] + aff[2,1]*verts[:,1] + aff[2,2]*verts[:,2] + aff[2,3]

    return coords

if __name__ == '__main__':

    parser = argparse.ArgumentParser()
    parser.add_argument('-in', '--mask', help='3D shape binary mask, as NIFTI file', type=str, required = True)
    parser.add_argument('-m', '--mesh', help='surface mesh generated by FreeSurfer, which corresponds to the mask nifti file, \
    as GIFTI file', type=str, required = True)
    parser.add_argument('-o', '--output', help='output directory', type=str, default = './mean_curvature_results3D')
    parser.add_argument('-dmap', '--dmap', help='distance_map: 0 if Euclidean, 1 if geodesic distance map, and 2 if binary step function', type=int, default = 1)

    args = parser.parse_args()

    # Example of use : python3 mean_curv_4_Freesurfer_output.py -in /home/karim/Bureau/Courbure/data/Guillaume_data/rh_white.nii.gz
    #-m /home/karim/Bureau/Courbure/data/Guillaume_data/rh.white.gii

    output_path = args.output

    if not os.path.exists(output_path):
        os.makedirs(output_path)


    nii = nib.load(args.mask)

    shape = nii.get_data()

    affine = nii.affine

    start_time = timeit.default_timer()

    #shape = g3D.bbox_3D(shape,5)

    if (args.dmap == 1):

        phi = g3D.phi(shape) ## signed geodesic distance

    elif (args.dmap == 2):

        phi = g3D.phi_binary(shape) ## binary step function

    else:

        phi = g3D.phi_Euclidean(shape) ## signed Euclidean distance

    gaussian_filter(phi, sigma=2, output=phi) ## smoothing of the level set signed distance function

    ########## Compute mean curvature ###################

    #curvature = divergence_formula(phi)   ### uncomment this line if you would like to run the divergence formula and comment the two following lines

    phi_grad, hessian = g3D.hessian(phi)
    mean_curvature = mean_curvature(phi_grad,hessian)

    ######################################################

    elapsed = timeit.default_timer() - start_time

    print("The proposed method takes (in seconds):\n")
    print(elapsed)

    ## load gifti mesh
    m = load_mesh(args.mesh)
    ## Express coordinates in the image coordinate system
    verts = map_coordinates(m.vertices,np.linalg.inv(affine))
    faces = m.faces
    normals = m.vertex_normals

    # Affect per-vertex curvature values, by interpolation
    #mean_curv = g3D.texture_mean_avg_interpolation3D(verts, mean_curvature)
    mean_curv = g3D.texture_nearest_neigh_interpolation3D(verts, mean_curvature)



    #print(np.min(mean_curv),np.max(mean_curv), np.mean(mean_curv))

    #### Save results as numpy array

    res = np.append(verts,mean_curv[...,None],axis=1)
    np.save(os.path.join(output_path, "mean_curv.npy"), res)
    print(res.shape)

    ## Display result

    g3D.display_mesh(verts, faces, normals, mean_curv, os.path.join(output_path, "mean_curvature_Makki_nearest.png"))


####To compare results with other methods defining the surface explicitly, please comment/uncomment the following blocks ###############


#######################################################################################################################################
################### To compare results with the Trimesh mean curvature, please uncomment this block ###################################

    start_time = timeit.default_timer()

    #tr_mean_curv = curvature.discrete_mean_curvature_measure(m, m.vertices, 2)
    tr_mean_curv = curvature.discrete_mean_curvature_measure(m, m.vertices, 2)

    elapsed = timeit.default_timer() - start_time

    print("The Trimesh method takes (in seconds):\n")

    print(elapsed)

    g3D.display_mesh(verts, faces, normals, tr_mean_curv, os.path.join(output_path, "Mean_curvature_Trimesh_radius2.png"))

#########################################################################################################################################

# #######################################################################################################################################
# ################## To compare results with the Rusinkiewicz (v1) mean curvature, please uncomment this block ##########################
#
#     start_time = timeit.default_timer()
#     # Comptue estimations of principal curvatures
#     PrincipalCurvatures, PrincipalDir1, PrincipalDir2 = scurv.curvatures_and_derivatives(m)
#     mean_curv = 0.5*(PrincipalCurvatures[0, :] + PrincipalCurvatures[1, :])
#
#     elapsed = timeit.default_timer() - start_time
#
#     print("The Rusinkiewicz method v1 takes (in seconds):\n")
#     print(elapsed)
#
#     #print(np.min(mean_curv),np.max(mean_curv), np.sqrt(np.absolute(np.mean(mean_curv)-(1/R))))
#     #gaussian_filter(mean_curv, sigma=1, output=mean_curv)
#     g3D.display_mesh(verts, faces, normals, mean_curv, os.path.join(output_path, "mean_curvature_Rusinkiewicz_v1.png"))
# #########################################################################################################################################


#########################################################################################################################################
##### To compare results with the Rusinkiewicz (v2) mean curvature, please uncomment this block #########################################
########################### Note that the second version is quite  faster than the first ################################################


    start_time = timeit.default_timer()

    #K,H,VN = WpFcurv.GetCurvatures(m.vertices,m.faces)
    mean_curv = WpFcurv.GetCurvatures(m.vertices,m.faces)[1]

    elapsed = timeit.default_timer() - start_time

    print("The Rusinkiewicz method v2 takes (in seconds):\n")
    print(elapsed)

    #gaussian_filter(mean_curv, sigma=1, output=gaussian_curv)
    g3D.display_mesh(verts, faces, normals, mean_curv, os.path.join(output_path, "mean_curvature_Rusinkiewicz_v2.png"))
##########################################################################################################################################


# #########################################################################################################################################
# ############## To compare results with those of the cubic order algorithm, please uncomment this block ##################################
#
#
#     start_time = timeit.default_timer()
#
#     #K,H,VN = ccurv.CurvatureCubic(m.vertices,m.faces)
#     mean_curv = ccurv.CurvatureCubic(m.vertices,m.faces)[1]
#
#     elapsed = timeit.default_timer() - start_time
#
#     print("The cubic order algorithm takes (in seconds):\n")
#     print(elapsed)
#
#     #gaussian_filter(mean_curv, sigma=1, output=mean_curv)
#     g3D.display_mesh(verts, faces, normals, mean_curv, os.path.join(output_path, "mean_curvature_cubic_order.png"))
# ##########################################################################################################################################

# #########################################################################################################################################
# ############## To compare results with the iterative fitting method, please uncomment this block ########################################
#
#
#     start_time = timeit.default_timer()
#
#     mean_curv = ISFcurv.CurvatureISF2(m.vertices,m.faces)[1]
#
#     elapsed = timeit.default_timer() - start_time
#
#     print("The iterative fitting method takes (in seconds):\n")
#     print(elapsed)
#
#     g3D.display_mesh(verts, faces, normals, mean_curv, os.path.join(output_path, "mean_curvature_iterative_fitting.png"))
# ##########################################################################################################################################

# #########################################################################################################################################
# ############## To compare results with the method of Meyer, please uncomment this block #################################################
#
#
#     start_time = timeit.default_timer()
#
#     A_mixed, mean_curvature_normal_operator_vector = diffgeo.calc_A_mixed(m.vertices, m.faces)
#     mean_curv = diffgeo.get_mean_curvature(mean_curvature_normal_operator_vector)
#
#     elapsed = timeit.default_timer() - start_time
#
#     print("The method of Meyer takes (in seconds):\n")
#     print(elapsed)
#
#     g3D.display_mesh(verts, faces, normals, mean_curv, os.path.join(output_path, "mean_curvature_Meyer.png"))
# ##########################################################################################################################################

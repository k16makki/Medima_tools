# -*- coding: utf-8 -*-

"""
  Â©
  Author: Karim Makki
"""

### Reference: "Makki, K, Ben Salem, Douraied and Ben Amor, Boulbaba. "Towards the assessment of intrinsic geometry of implicit brain MRI manifolds." IEEE Access (2021)"

import numpy as np
import nibabel as nib
import os
from scipy.ndimage.filters import gaussian_filter
import argparse
import timeit
import fast_Gaussian_curvature_3D as g3D
import fast_mean_curvature_3D as m3D
import Gauss_curv_4_Freesurfer_output as GFS

## Import tools for computing curvature on explicit surfaces / i.e. triangle meshes (for comparison purposes)
import slam_curvature as scurv
import CurvatureCubic as ccurv
import CurvatureWpF as WpFcurv
import CurvatureISF as ISFcurv
from trimesh import curvature
import DiffGeoOps as diffgeo



if __name__ == '__main__':

    parser = argparse.ArgumentParser()
    parser.add_argument('-in', '--mask', help='3D shape binary mask, as NIFTI file', type=str, required = True)
    parser.add_argument('-m', '--mesh', help='surface mesh generated by FreeSurfer, which corresponds to the mask nifti file, \
    as GIFTI file', type=str, required = True)
    parser.add_argument('-o', '--output', help='output directory', type=str, default = './mean_curvature_results3D')
    parser.add_argument('-dmap', '--dmap', help='distance_map: 0 if Euclidean, 1 if geodesic distance map, and 2 if binary step function', type=int, default = 1)

    args = parser.parse_args()

    # Example of use : python3 mean_curv_4_Freesurfer_output.py -in /home/karim/Bureau/Courbure/data/Guillaume_data/rh_white.nii.gz
    #-m /home/karim/Bureau/Courbure/data/Guillaume_data/rh.white.gii

    output_path = args.output

    if not os.path.exists(output_path):
        os.makedirs(output_path)


    nii = nib.load(args.mask)

    shape = nii.get_data()

    affine = nii.affine

    start_time = timeit.default_timer()

    shape, dx, dy, dz = g3D.bbox_3D(shape)

    if (args.dmap == 1):

        phi = g3D.phi(shape) ## signed geodesic distance

    elif (args.dmap == 2):

        phi = g3D.phi_binary(shape) ## binary step function

    else:

        phi = g3D.phi_Euclidean(shape) ## signed Euclidean distance

    gaussian_filter(phi, sigma=1, output=phi) ## smoothing of the level set signed distance function

    ########## Compute mean curvature ###################

    #mean_curvature = m3D.divergence_formula(phi)   ### uncomment this line (and comment the two following) if you would like to use the divergence formula

    phi_grad, hessian = g3D.hessian(phi)
    mean_curvature = m3D.mean_curvature(phi_grad,hessian)

    ######################################################

    elapsed = timeit.default_timer() - start_time

    print("The proposed method takes (in seconds):\n")
    print(elapsed)

    ## load gifti mesh
    m = GFS.load_mesh(args.mesh)
    ## Express vertex coordinates in the image coordinate system
    verts = GFS.map_coordinates(m.vertices,np.linalg.inv(affine))

    verts = g3D.align_origin(verts,dx,dy,dz) ### Align origin with the origin of the bounding box

    # Affect per-vertex curvature values, by interpolation

    #mean_curv = g3D.texture_mean_avg_interpolation3D(verts, mean_curvature)
    #mean_curv = g3D.texture_nearest_neigh_interpolation3D(verts, mean_curvature)
    mean_curv = g3D.texture_spline_interpolation3D(verts, mean_curvature)

    verts = g3D.align_origin_back(verts,dx,dy,dz) ### Re-align origin "back" with the origin of the original image

    #### Save results as numpy array

    res = np.append(verts,mean_curv[...,None],axis=1)
    np.save(os.path.join(output_path, "mean_curv.npy"), res)
    print(res.shape)

    ## Display result

    g3D.display_mesh(m.vertices, m.faces, m.vertex_normals, mean_curv, os.path.join(output_path, "mean_curvature_Makki_nearest.png"))


####To compare results with other methods defining the surface explicitly, please comment/uncomment the following blocks ###############


# #######################################################################################################################################
# ################### To compare results with the Trimesh mean curvature, please uncomment this block ###################################
#
#     start_time = timeit.default_timer()
#
#     #tr_mean_curv = curvature.discrete_mean_curvature_measure(m, m.vertices, 2)
#     tr_mean_curv = curvature.discrete_mean_curvature_measure(m, m.vertices, 2)
#
#     elapsed = timeit.default_timer() - start_time
#
#     print("The Trimesh method takes (in seconds):\n")
#
#     print(elapsed)
#
#     g3D.display_mesh(m.vertices, m.faces, m.vertex_normals, tr_mean_curv, os.path.join(output_path, "Mean_curvature_Trimesh_radius2.png"))
#
# #########################################################################################################################################
#
# #######################################################################################################################################
# ################## To compare results with the Rusinkiewicz (v1) mean curvature, please uncomment this block ##########################
#
#     start_time = timeit.default_timer()
#     # Comptue estimations of principal curvatures
#     PrincipalCurvatures, PrincipalDir1, PrincipalDir2 = scurv.curvatures_and_derivatives(m)
#     mean_curv = 0.5*(PrincipalCurvatures[0, :] + PrincipalCurvatures[1, :])
#
#     elapsed = timeit.default_timer() - start_time
#
#     print("The Rusinkiewicz method v1 takes (in seconds):\n")
#     print(elapsed)
#
#     #print(np.min(mean_curv),np.max(mean_curv), np.sqrt(np.absolute(np.mean(mean_curv)-(1/R))))
#     #gaussian_filter(mean_curv, sigma=1, output=mean_curv)
#     g3D.display_mesh(m.vertices, m.faces, m.vertex_normals, mean_curv, os.path.join(output_path, "mean_curvature_Rusinkiewicz_v1.png"))
# #########################################################################################################################################
#
#
# #########################################################################################################################################
# ##### To compare results with the Rusinkiewicz (v2) mean curvature, please uncomment this block #########################################
# ########################### Note that the second version is quite  faster than the first ################################################
#
#     start_time = timeit.default_timer()
#
#     #K,H,VN = WpFcurv.GetCurvatures(m.vertices,m.faces)
#     mean_curv = WpFcurv.GetCurvatures(m.vertices,m.faces)[1]
#
#     elapsed = timeit.default_timer() - start_time
#
#     print("The Rusinkiewicz method v2 takes (in seconds):\n")
#     print(elapsed)
#
#     #gaussian_filter(mean_curv, sigma=1, output=gaussian_curv)
#     g3D.display_mesh(m.vertices, m.faces, m.vertex_normals, mean_curv, os.path.join(output_path, "mean_curvature_Rusinkiewicz_v2.png"))
# ##########################################################################################################################################
#
#
# #########################################################################################################################################
# ############## To compare results with those of the cubic order algorithm, please uncomment this block ##################################
#
#
#     start_time = timeit.default_timer()
#
#     #K,H,VN = ccurv.CurvatureCubic(m.vertices,m.faces)
#     mean_curv = ccurv.CurvatureCubic(m.vertices,m.faces)[1]
#
#     elapsed = timeit.default_timer() - start_time
#
#     print("The cubic order algorithm takes (in seconds):\n")
#     print(elapsed)
#
#     #gaussian_filter(mean_curv, sigma=1, output=mean_curv)
#     g3D.display_mesh(m.vertices, m.faces, m.vertex_normals, mean_curv, os.path.join(output_path, "mean_curvature_cubic_order.png"))
# ##########################################################################################################################################
#
# #########################################################################################################################################
# ############## To compare results with the iterative fitting method, please uncomment this block ########################################
#
#
#     start_time = timeit.default_timer()
#
#     mean_curv = ISFcurv.CurvatureISF2(m.vertices,m.faces)[1]
#
#     elapsed = timeit.default_timer() - start_time
#
#     print("The iterative fitting method takes (in seconds):\n")
#     print(elapsed)
#
#     g3D.display_mesh(m.vertices, m.faces, m.vertex_normals, mean_curv, os.path.join(output_path, "mean_curvature_iterative_fitting.png"))
# ##########################################################################################################################################
#
# #########################################################################################################################################
# ############## To compare results with the method of Meyer, please uncomment this block #################################################
#
#
#     start_time = timeit.default_timer()
#
#     A_mixed, mean_curvature_normal_operator_vector = diffgeo.calc_A_mixed(m.vertices, m.faces)
#     mean_curv = diffgeo.get_mean_curvature(mean_curvature_normal_operator_vector)
#
#     elapsed = timeit.default_timer() - start_time
#
#     print("The method of Meyer takes (in seconds):\n")
#     print(elapsed)
#
#     g3D.display_mesh(m.vertices, m.faces, m.vertex_normals, mean_curv, os.path.join(output_path, "mean_curvature_Meyer.png"))
# ##########################################################################################################################################

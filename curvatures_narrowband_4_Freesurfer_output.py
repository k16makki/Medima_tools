# -*- coding: utf-8 -*-

"""
  Â©
  Author: Karim Makki
"""

import trimesh
import numpy as np
import nibabel as nib
import os
from scipy.ndimage.filters import gaussian_filter
import argparse
import  skfmm
from skimage import measure
import timeit
import fast_Gaussian_curvature_3D as g3D
import curvatures_narrowband as cnb
import Gauss_curv_4_Freesurfer_output as gFO



if __name__ == '__main__':

    parser = argparse.ArgumentParser()
    parser.add_argument('-in', '--mask', help='3D shape binary mask generated by Freesurfer, as NIFTI file', type=str, required = True)
    parser.add_argument('-m', '--mesh', help='surface mesh generated by FreeSurfer, which corresponds to the mask nifti file, \
    as GIFTI file', type=str, required = True)
    parser.add_argument('-o', '--output', help='output directory', type=str, default = './Gaussian_curvature_results3D')

    args = parser.parse_args()

    # Example of use : python3 curvatures_narrowband_4_Freesurfer_output.py -in /home/karim/Bureau/Courbure/data/Guillaume_data/rh_white.nii.gz
    #-m /home/karim/Bureau/Courbure/data/Guillaume_data/rh.white.gii -o /home/karim/Bureau/Courbure/narrow_band_Freesurfer

    output_path = args.output

    if not os.path.exists(output_path):
        os.makedirs(output_path)


    nii = nib.load(args.mask)
    shape = nii.get_data()


    start_time = timeit.default_timer()

    shape, dx, dy, dz = g3D.bbox_3D(shape,7)

    phi, R = cnb.phi_narrow(shape,7) ## distance calculation limited to narrow band
    phi = cnb.local_gaussian_filter(phi, sigma=2) ## smoothing of the level set signed distance function on a narrow band

#################### Computation of  Gaussian and mean curvatures ###############################
    phi_grad, hessian = g3D.hessian(phi)  ### To do in narrowband
    Ha = cnb.hessian_adjoint_narrowband(hessian,R)
    Gaussian_curvature, mean_curvature = cnb.curvatures_narrowband(phi_grad,Ha,hessian,R)
#################################################################################################
#################### Computation of  principal curvatures #######################################
    K1, K2 = cnb.principal_curvatures(mean_curvature, Gaussian_curvature)
#################################################################################################
    # extract explicitly the implicit surface mesh using the scikit-image toolbox

    mesh = gFO.load_mesh(args.mesh)
    ## Express vertex coordinates in the image coordinate system
    verts = gFO.map_coordinates(mesh.vertices,np.linalg.inv(nii.affine))
    ### Align origin with the origin of the bounding box
    verts = g3D.align_origin(verts,dx,dy,dz)


    ### Affect per-vertex curvature values, with a nearest neighbour interpolation of vertices on the grid
    gaussian_curv = g3D.texture_spline_interpolation3D(verts, Gaussian_curvature)
    mean_curv = g3D.texture_spline_interpolation3D(verts, mean_curvature)
    k1 = g3D.texture_spline_interpolation3D(verts, K1)
    k2 = g3D.texture_spline_interpolation3D(verts, K2)



    elapsed = timeit.default_timer() - start_time
    print("The proposed method takes (in seconds):\n")
    print(elapsed)

    ### Re-align origin "back" with the origin of the original image

    verts = g3D.align_origin_back(verts,dx,dy,dz)

    m = trimesh.Trimesh(vertices=verts, faces=mesh.faces)
    m.export(os.path.join(output_path, "surface_mesh.obj"))

    print(output_path)

    #### Save results as numpy array arrays

    cnb.save_result(verts,gaussian_curv,os.path.join(output_path,"gaussian_curv.npy"))
    cnb.save_result(verts,mean_curv,os.path.join(output_path,"mean_curv.npy"))
    cnb.save_result(verts,k1,os.path.join(output_path,"min_curv.npy"))
    cnb.save_result(verts,k2,os.path.join(output_path,"max_curv.npy"))
    cnb.save_result(verts,2*gaussian_curv,os.path.join(output_path,"Ricci_scalar.npy"))

    ## Display results

    g3D.display_mesh(mesh.vertices, mesh.faces, mesh.vertex_normals, gaussian_curv, os.path.join(output_path, "Gaussian_curvature_Makki.png"))
    g3D.display_mesh(mesh.vertices, mesh.faces, mesh.vertex_normals, 2*gaussian_curv, os.path.join(output_path, "Ricci_scalar_Makki.png"))
    g3D.display_mesh(mesh.vertices, mesh.faces, mesh.vertex_normals, mean_curv, os.path.join(output_path, "mean_curvature_Makki.png"))
    g3D.display_mesh(mesh.vertices, mesh.faces, mesh.vertex_normals, k1, os.path.join(output_path, "Minimum_curvature_Makki.png"))
    g3D.display_mesh(mesh.vertices, mesh.faces, mesh.vertex_normals, k2, os.path.join(output_path, "Maximum_curvature_Makki.png"))
